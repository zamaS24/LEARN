# Notes of REACT JS from [JS Maestry](https://www.youtube.com/watch?v=b9eMGE7QtTk)


> ### **üßµsommaire**
> [Component]()  
> [Using CSS]()
> [JSX]()  
> [React fragment]()  
> [Props]()  
> [UseState]()  
> [useEffect]()  
> [Hooks]()  


### not React
[Lien vers powtoon le site pour faire des pr√©sentations cool](https://www.powtoon.com/)


# Folder Strucutre 
* `node_modules` dierctory : modules to be imported 
* `public`: static public files, like : index.html... icons .. etc
* `src` : here is the source code of the react code, here there is all of the js and the css, you don't want to share with other, 
yo might ask how th index.html know where th js is, but the webpack use it by itself so don't worry. 
* `.gitignore` file : what should not be imported when pushing project to github

* `package-lock.json`  : package-lock.json is a file that is automatically generated by npm when a package is installed. It records the exact version of every installed dependency, including its sub-dependencies and their versions.
package-lock.json is created by npm when you run the npm install command. It contains a detailed list of all the packages, their dependencies, their specific version numbers, and locations (usually mentioned in the package.json file)
The purpose of package-lock.json is to ensure that the same dependencies are installed consistently across different environments, such as development and production environments.


* `package.json`: specify dependencies, metadata, (name, project), scripts, configurations . in a normal mode this file is generated with npm like : npm init



# npm & npx 
* `Node package manager (npm)` : is primarily used for managing packages and dependencies in your Node.js projects.   
* `NOde pakcage execturoe (npx)` : it is a package runner tool, it comes with npm from versio 5.0.2 I believe tool designed to execute Node packages directly, without the need to install them globally. 

melekher the first one is used for: `npm install`, ..etc  
the other one is to execcute like :`npx <package-name> [args]`

## npm start
In a package.json file, the "scripts" section is used to define various commands that can be executed via npm (Node Package Manager). These scripts allow you to perform common development and build tasks for your project with simple npm commands.

```json
"scripts": {
  "start": "node server.js",
  "build": "webpack --mode production",
  "test": "jest"
}
```
How npm start Executes the Command  

1. Script Lookup:  
npm start looks for the "start" script in your package.json. In your case, it finds "start": "react-scripts start".
Local `node_modules/.bin`:  

running npm start will be equivalent at running `./node_modules/.bin/react-scripts start`
or running `npx start` 

> :warning: **Important**   
>2. When executing the script defined in package.json, npm automatically includes the **node_modules/.bin** directory in the PATH for that command execution. This directory contains executables for locally installed packages.    

3. Command Execution:
npm then runs the react-scripts start command. Since node_modules/.bin is in the PATH during this execution, it can find react-scripts and execute it.


During the execution of this script, npm temporarily modifies the PATH environment variable to include ./node_modules/.bin. This ensures that any binaries installed locally are available for execution.

## Why `npm start` but `npm run build`?

The difference is due to a shorthand feature in `npm`.

- **`npm start`**: `start` is a special script name in `npm`, so you can run it without the `run` keyword.

- **`npm run build`**: For scripts other than `start`, `stop`, `test`, and `restart`, you need to use `npm run`.

In short, you use `npm start` because `start` is a recognized shorthand, but for other custom scripts like `build`, you need to write `npm run build`.

## npm install -g \<pacakge-name>  
we can install a package globally and run it anywhere from our terminal 
npm install -g 

## npx example 
lets say you want to create a certain package that will be run after the same as npx create-react-app  
let's say it's my-npx-project

1. first we need to have  a package.json file   
  -> $ npm init -y 

2. create a simple script named hello.js and make it in the folder `bin/`this is important because when I do only the script, when I try to execute the package later with npx, it only opens the file, but with this folder structure it actually exectues it. I didn't make the file executable as mentioned in step 4 although. 

```js
// hello.js
console.log("Hello, NPX!");
```


3. to make it easy to run our script we add this command to the package.json 
    ```js
    "bin": {
      "hello": "./hello.js"
    },
    ```
4. make script executable 
    ```bash 
    chmod +x hello.js
    ```

5. add shebang on top of script.js 
    ```bash
    #!/usr/bin/env node
    ```

6. link the package locally 
    ```bash
    npm link
    ```
   This command will link your project globally. The hello command specified in the bin section of your package.json will now be available globally.

Now, when you run `npx hello`, it will find your globally linked hello command and execute hello.js.


basically the npx, will fetch the package execute it and without saving it. example : npx cowsay hello 

> **INFO** :bulb:   
> if you install the package globally, you can just run it with $\<package_name> 
> $npx hello or $npx hello 


## conclusion: 
npx : for execution, and also servers for remote fetching without installing. 
for making it in local (myown project) gotta pass by the steps and link and make executable and specify the "bin" in package.json

npm works with packages and installs them, and also checks the scripts, also sometiems don't forget that he looks up to the node modules bin, so don't be surprised if you find a command in scripts that you wouldn't work when you directly execute it from console.

# how importing packages work internally  
Node finds the package in `node_modules/ `   
- It looks for `package.json` inside the package folder
- If `package.json` exists, it checks the` "main"` field.
- If `"main"` is missing, it defaults to `index.js`.
- It loads whatever `index.js` exports.


# Virtual DOM 
React js uses virutal DOM instead of DOM 
- updating the virtual DOM is faster than updating the real DOM 
- React only updates the section of the page, instead of the whole page

# Component 
React js is a `component-based` front end library
- all parts of our web applications are divided into components 
- A componenet is a small piece of the user interface
- Every React js application is a tree of components

# USING CSS 
when writing our components, we just need to import the css file and it will automatically know which css to be applied to that component

# JSX (HTML inside js )
JSX is a syntax extension for JavaScript which allows you to write HTML-like structures in your JavaScript code.
Describe what the user interface should look like
**example**
```jsx
const name = "John";
const greeting = <p>Hello, {name}!</p>;
```
in React (and JSX in general), the {} is used to evaluate JavaScript expressions and embed the result into the JSX output.


# Create react app

```bash 
npx create-react-app ./

# ./ pour dire qu'on va installer dans ce dossier local (current folder)
```

# How it works
- in index.html file we have a root div.
in index.js

- with the ReactDOM we take the root element and then 
perform on it with root.render()

- in app.js we have JSX and not HTML
- in jsx we use `ClassName` instead of class, beacuse class is a reserved keyword in js

# react fragment

**primarly for the multiple elements**  
ce qui est entre `<></>`
* RULE: if we want to render two different elements, we need to wrap them in a react fragment
inject some react inside the `{}`
```js
 return (
    <div className="App">
     <h1>Hello react ! </h1>
     
     {! name?(
        <> {name} </>
      ):(
        <>
          <h1>Test</h1>
        </>
      )}
  
    </div>
      
  )
```

# Components 
A component is a piece of code that returns some JSX 

```jsx
const Person = ({firstname, lastname, age}) => {
  return (
    <>
      <h1>Name : Hamza </h1>
      <h1>Last name : OMARI</h1>
      <h2>Age: 30</h2>
    </>
  )
}
```

## calling a component 
```jsx
// syntax: </ComponentName>
<Person />
```

# Props 
Props are arguments you pass to a react component
By default when you create a component the first argument is the object holding tha rguments

# defining and setting the parameters
```jsx
const myComponent = (props) => {
    return(
        <>
        <h1> Name: {props.name} </h1>
        </>
    )
}
```

# passing parameters (props)
> :bulb: **NOTE**  
> you can here use the slicing, see the example of moviecard
> {movie}: means slicing the props object, to only getting the movie parameter
```jsx
const App = ()=> {
  return (
    <div className="App">


     <Person name={'Hamza'} />
    //  or 

    <Person name='Hamza'>
     <Person />
     <Person />
    </div>
      
  );
}
```

<br>

## Conditional rendering 
you can store that component call in a variable
```jsx
let content;
if (isLoggedIn) {
  content = <AdminPanel />;
} else {
  content = <LoginForm />;
}
return (
  <div>
    {content}
  </div>
);
```

# useState
## definition 
`useState` is a hook in React, which is a feature introduced in React 16.8 to manage state in functional components. It allows you to add state management to your functional components, making them capable of maintaining and updating their own state data. 

> :bulb: **NOTE**  
> React rerenders the component each time the state change

## import 
```js
import {useState} from 'react'
```

## Syntax
```js
const [state, setState] = useState(initialValue);
```

## Example 
```js
let [counter, setCounter] = useState(0);
```

## React Developer Tool
React DevTools let you check the props and the state of your React components. you can add it as an extension, also to use it you can just go on inspect mode 

## Calling
the `setState() function takes a callback as an argument or directly a value`
* case callback : operates on the counter variable   
example: 
  ```jsx
  const [counter, setCounter] = useState(0);
  <button onClick= {
          ()=>{
            setCounter((prevCount) => {
              prevCount --;
              return prevCount;
            })
          }
        } >-</button>
      
  ```
  see that counter is constant

<br>

# useEffect
the useEffect hook in React will run each time one of its dependencies changes. The dependencies are specified as the second argument to useEffect in the form of an array. When any of the values in that array change between renders, the effect will be executed.

```js
useEffect(() => {
  // This code will run whenever any of the dependencies change
  // ...
}, [dependency1, dependency2, ...]);

```
# Hooks
useState et useEffect sont des hooks, il ya plusieurs hooks, on peut avoir, plusieurs hooks par component, c'est possible


# single file components
In react when we want like to write a component in a single file it's preferable
to write it in a `.jsx` file format. 

# Important
- About callbacks onClick and react 
chatGPT: Yes, you're correct. In React, it's a common pattern to use an arrow function or a callback function without arguments directly within the onClick attribute, and then call the desired function or logic inside that callback. This approach is often used to pass additional parameters or to control when the logic should execute.



# Import CSS
for exaample in the app.js we want to apply some css, so for that we need to create the `App.css` file and then include it with `import './App.css'`


# Forms 
remember a form has methods `POST` or `GET`   

`for ='id of elmenet of this label'` it's for attaching the label with the actual item for example: 

`name` which is used for the actual data that will be retrieved from the server (for example how I used to do it in PHP) 

```js
<form>
  <label for="fname">First name:</label><br>
  <input type="text" id="fname" name="fname"><br>
  <label for="lname">Last name:</label><br>
  <input type="text" id="lname" name="lname">
</form>
```



A simple react form 
htmlFor attribute is the fo
```js
<form>
      // first input
      <label htmlFor="name">Name</label>
      <input
        type="text"
        name="name"
        id="name"
        value={name}
        onChange={this.handleChange} />


      <label htmlFor="job">Job</label>
      <input
        type="text"
        name="job"
        id="job"
        value={job}
        onChange={this.handleChange} />

    </form>

```





# Things I find so good in the tic tac toe tutorial 
-> shared state between buttons and Board compoent   
-> array(9): as useState() of the baord component, but also 
-> You should always like think of what the UI shall be like, and then just play with the data, making your backend and you're sure that the ui is updating the screen when data that is should be sen on the screen is updated.

- By updating the array values, rerendering is triggered out, and the value of the array is changed, and we described that the value of the square should be the value of the array, hence it will be updated.



- The square has no data in its component definition, that's because as I said before it's realted to the data on the baord.



# Very import things 
In a functional component, a regular variable gets reset every time the component re-renders.